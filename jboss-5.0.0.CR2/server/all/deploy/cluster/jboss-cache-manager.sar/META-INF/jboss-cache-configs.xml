<?xml version="1.0" encoding="UTF-8"?>

<cache-configs>

    <!-- 
      | A config appropriate for HttpSession caches.
      | Not for use with FIELD replication granularity webapps.
    -->
    <cache-config name="standard-session-cache">

        <attribute name="TransactionManagerLookupClass">org.jboss.cache.transaction.BatchModeTransactionManagerLookup</attribute>

        <attribute name="NodeLockingScheme">PESSIMISTIC</attribute>
        <attribute name="IsolationLevel">REPEATABLE_READ</attribute>

        <!-- Valid modes are REPL_ASYNC and REPL_SYNC -->
        <attribute name="CacheMode">REPL_ASYNC</attribute>

        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">${jboss.partition.name:DefaultPartition}-SessionCache</attribute>
        
        <!-- Use a UDP (multicast) based stack. Need JGroups flow control (FC)
             because we are using asynchronous replication.
        -->
        <attribute name="MultiplexerStack">${jboss.default.jgroups.stack:udp}</attribute>

        <!-- Must fetch state. -->
        <attribute name="FetchInMemoryState">true</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup.
        -->
        <attribute name="StateRetrievalTimeout">60000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">17500</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

        <!-- Region-based marshalling is not needed. -->
        <attribute name="UseRegionBasedMarshalling">false</attribute>
        <!-- Must match the value of "UseRegionBasedMarshalling" -->
        <attribute name="InactiveOnStartup">false</attribute>
           
        <attribute name="ExposeManagementStatistics">true</attribute>

        <!-- Buddy Replication config -->
        <attribute name="BuddyReplicationConfig">
          <config>
            <buddyReplicationEnabled>false</buddyReplicationEnabled>
            <buddyLocatorClass>org.jboss.cache.buddyreplication.NextMemberBuddyLocator</buddyLocatorClass>
            <!-- numBuddies is the number of backup nodes each node maintains.  
                 ignoreColocatedBuddies means that each node will *try* to 
                 select a buddy on a different physical host. If not able to do 
                 so though, it will fall back to colocated nodes. -->
            <buddyLocatorProperties>
               numBuddies = 1
               ignoreColocatedBuddies = true
            </buddyLocatorProperties>

            <!-- A way to specify a preferred replication group.  If specified, 
                 we try and pick a buddy why shares the same pool name (falling 
                 back to other buddies if not available).  This allows the sysdmin 
                 to hint at backup buddies are picked, so for example, nodes may 
                 be hinted topick buddies on a different physical rack or power 
                 supply for added fault tolerance.  
            -->
            <buddyPoolName>default</buddyPoolName>
            <!-- communication timeout for inter-buddy group organisation 
                 messages (such as assigning to and removing from groups -->
            <buddyCommunicationTimeout>17500</buddyCommunicationTimeout>

            <!-- Do not change these -->
            <autoDataGravitation>false</autoDataGravitation>
            <dataGravitationRemoveOnFind>true</dataGravitationRemoveOnFind>
            <dataGravitationSearchBackupTrees>true</dataGravitationSearchBackupTrees>

          </config>
        </attribute>
        
        <!-- Cache Loader for session passivation --> 
        <attribute name="CacheLoaderConfig">
          <config>
            <passivation>true</passivation>
            <shared>false</shared>

            <purgeOnStartup>true</purgeOnStartup>

            <cacheloader>
               <class>org.jboss.cache.loader.FileCacheLoader</class>
               <properties>
                  location=${jboss.server.data.dir}${/}session
               </properties>
               <async>false</async>
               <fetchPersistentState>true</fetchPersistentState>
               <ignoreModifications>false</ignoreModifications>
               <checkCharacterPortability>false</checkCharacterPortability>
            </cacheloader>

          </config>
        </attribute>

        <!-- 
           JBoss Cache eviction is not needed; webapp or SFSB container 
           manages eviction by itself.
        -->

    </cache-config>

    <!-- 
      | A config appropriate for HttpSession caches for webapps 
      | that use FIELD replication granularity.
    -->
    <cache-config name="field-granularity-session-cache">

        <attribute name="TransactionManagerLookupClass">org.jboss.cache.transaction.BatchModeTransactionManagerLookup</attribute>

        <attribute name="NodeLockingScheme">PESSIMISTIC</attribute>
        <attribute name="IsolationLevel">REPEATABLE_READ</attribute>

        <!-- Valid modes are LOCAL
                             REPL_ASYNC
                             REPL_SYNC
        -->
        <attribute name="CacheMode">REPL_ASYNC</attribute>

        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">${jboss.partition.name:DefaultPartition}-FieldSessionCache</attribute>
        
        <!-- Use a UDP (multicast) based stack. Need JGroups flow control (FC)
             because we are using asynchronous replication.
        -->
        <attribute name="MultiplexerStack">${jboss.default.jgroups.stack:udp}</attribute>

        <!-- Must fetch state. -->
        <attribute name="FetchInMemoryState">true</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup.
        -->
        <attribute name="StateRetrievalTimeout">60000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">17500</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

        <!--
          Indicate whether to use marshalling or not. Set this to true if you 
          are running under a scoped class loader, e.g., inside an application 
          server. Default is "false".
        -->
        <attribute name="UseRegionBasedMarshalling">true</attribute>
        <!-- Must match the value of "useRegionBasedMarshalling" -->
        <attribute name="InactiveOnStartup">true</attribute>
           
        <attribute name="ExposeManagementStatistics">true</attribute>

        <!-- Buddy Replication config -->
        <attribute name="BuddyReplicationConfig">
          <config>
            <buddyReplicationEnabled>false</buddyReplicationEnabled>
            <buddyLocatorClass>org.jboss.cache.buddyreplication.NextMemberBuddyLocator</buddyLocatorClass>
            <!-- numBuddies is the number of backup nodes each node maintains.  
                 ignoreColocatedBuddies means that each node will *try* to 
                 select a buddy on a different physical host. If not able to do 
                 so though, it will fall back to colocated nodes. -->
            <buddyLocatorProperties>
               numBuddies = 1
               ignoreColocatedBuddies = true
            </buddyLocatorProperties>

            <!-- A way to specify a preferred replication group.  If specified, 
                 we try and pick a buddy why shares the same pool name (falling 
                 back to other buddies if not available).  This allows the sysdmin 
                 to hint at backup buddies are picked, so for example, nodes may 
                 be hinted topick buddies on a different physical rack or power 
                 supply for added fault tolerance.  
            -->
            <buddyPoolName>default</buddyPoolName>
            <!-- communication timeout for inter-buddy group organisation 
                 messages (such as assigning to and removing from groups -->
            <buddyCommunicationTimeout>17500</buddyCommunicationTimeout>

            <!-- Do not change these -->
            <autoDataGravitation>false</autoDataGravitation>
            <dataGravitationRemoveOnFind>true</dataGravitationRemoveOnFind>
            <dataGravitationSearchBackupTrees>true</dataGravitationSearchBackupTrees>

          </config>
        </attribute>
        
        <!-- Cache Loader for session passivation --> 
        <attribute name="CacheLoaderConfig">
          <config>
            <passivation>true</passivation>
            <shared>false</shared>

            <purgeOnStartup>true</purgeOnStartup>

            <cacheloader>
               <class>org.jboss.cache.loader.FileCacheLoader</class>
               <properties>
                  location=${jboss.server.data.dir}${/}field-session
               </properties>
               <async>false</async>
               <fetchPersistentState>true</fetchPersistentState>
               <ignoreModifications>false</ignoreModifications>
               <checkCharacterPortability>false</checkCharacterPortability>
            </cacheloader>

          </config>
        </attribute>

        <!-- FIELD granularity webapps use JBoss Cache eviction -->
        <attribute name="EvictionPolicyConfig">
          <config>
            <attribute name="wakeUpIntervalSeconds">5</attribute>
            <!-- Name of the DEFAULT eviction policy class. -->
            <attribute name="policyClass">org.jboss.cache.eviction.NullEvictionPolicy</attribute>
            <!--  Cache wide default region -->
            <region name="/_default_"/>
            <!-- JBossWeb integration code will programatically create
                 other regions as webapps are deployed -->
          </config>
        </attribute>

    </cache-config>

    <!-- 
      | A config appropriate for EJB3 SFSB caching.
    -->
    <cache-config name="sfsb-cache">
        <!--  No transaction manager lookup -->
        
        <attribute name="NodeLockingScheme">PESSIMISTIC</attribute>
        <attribute name="IsolationLevel">REPEATABLE_READ</attribute>

        <!-- Valid modes are LOCAL
                             REPL_ASYNC
                             REPL_SYNC
        -->
        <attribute name="CacheMode">REPL_ASYNC</attribute>

        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">${jboss.partition.name:DefaultPartition}-SFSBCache</attribute>
        
        <!-- Use a UDP (multicast) based stack. Need JGroups flow control (FC)
             because we are using asynchronous replication.
        -->
        <attribute name="MultiplexerStack">${jboss.default.jgroups.stack:udp}</attribute>

        <!-- Must fetch state. -->
        <attribute name="FetchInMemoryState">true</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup.
        -->
        <attribute name="StateRetrievalTimeout">60000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">17500</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

        <!--
          SFSBs use region-based marshalling to provide for partial state
          transfer during deployment/undeployment.
        -->
        <attribute name="UseRegionBasedMarshalling">true</attribute>
        <!-- Must match the value of "useRegionBasedMarshalling" -->
        <attribute name="InactiveOnStartup">true</attribute>
           
        <attribute name="ExposeManagementStatistics">true</attribute>

        <!-- Buddy Replication config -->
        <attribute name="BuddyReplicationConfig">
          <config>
            <buddyReplicationEnabled>false</buddyReplicationEnabled>
            <buddyLocatorClass>org.jboss.cache.buddyreplication.NextMemberBuddyLocator</buddyLocatorClass>
            <!-- numBuddies is the number of backup nodes each node maintains.  
                 ignoreColocatedBuddies means that each node will *try* to 
                 select a buddy on a different physical host. If not able to do 
                 so though, it will fall back to colocated nodes. -->
            <buddyLocatorProperties>
               numBuddies = 1
               ignoreColocatedBuddies = true
            </buddyLocatorProperties>

            <!-- A way to specify a preferred replication group.  If specified, 
                 we try and pick a buddy why shares the same pool name (falling 
                 back to other buddies if not available).  This allows the sysdmin 
                 to hint at backup buddies are picked, so for example, nodes may 
                 be hinted topick buddies on a different physical rack or power 
                 supply for added fault tolerance.  
            -->
            <buddyPoolName>default</buddyPoolName>
            <!-- communication timeout for inter-buddy group organisation 
                 messages (such as assigning to and removing from groups -->
            <buddyCommunicationTimeout>17500</buddyCommunicationTimeout>

            <!-- Do not change these -->
            <autoDataGravitation>false</autoDataGravitation>
            <dataGravitationRemoveOnFind>true</dataGravitationRemoveOnFind>
            <dataGravitationSearchBackupTrees>true</dataGravitationSearchBackupTrees>

          </config>
        </attribute>
        
        <!-- Cache Loader for session passivation --> 
        <attribute name="CacheLoaderConfig">
          <config>
            <passivation>true</passivation>
            <shared>false</shared>

            <purgeOnStartup>true</purgeOnStartup>

            <cacheloader>
               <class>org.jboss.cache.loader.FileCacheLoader</class>
               <properties>
                  location=${jboss.server.data.dir}${/}sfsb
               </properties>
               <async>false</async>
               <fetchPersistentState>true</fetchPersistentState>
               <ignoreModifications>false</ignoreModifications>
               <checkCharacterPortability>false</checkCharacterPortability>
            </cacheloader>

          </config>
        </attribute>

        <!-- SFSBs use JBoss Cache eviction -->
        <attribute name="EvictionPolicyConfig">
          <config>
            <attribute name="wakeUpIntervalSeconds">5</attribute>
            <!-- Name of the DEFAULT eviction policy class. -->
            <attribute name="policyClass">org.jboss.cache.eviction.NullEvictionPolicy</attribute>
            <!--  Cache wide default region -->
            <region name="/_default_"/>
            <!-- EJB3 integration code will programatically create
                 other regions as beans are deployed -->
          </config>
        </attribute>

    </cache-config>

    <!-- 
      | A config appropriate for the HAPartition-based services, e.g.
      | DistributedState, HA-JNDI. Also valid for use by the JBossWeb 
      | ClusteredSingleSignOn valve.
    -->
    <cache-config name="ha-partition">

        <attribute name="TransactionManagerLookupClass">org.jboss.cache.transaction.BatchModeTransactionManagerLookup</attribute>

        <attribute name="NodeLockingScheme">PESSIMISTIC</attribute>
        <attribute name="IsolationLevel">REPEATABLE_READ</attribute>

        <attribute name="CacheMode">REPL_SYNC</attribute>

        <attribute name="ClusterName">${jboss.partition.name:DefaultPartition}-HAPartitionCache</attribute>
        
        <!-- Use a UDP (multicast) based stack. Need JGroups flow control (FC)
             because we are using asynchronous replication.
        -->
        <attribute name="MultiplexerStack">${jboss.default.jgroups.stack:udp}</attribute>

        <attribute name="FetchInMemoryState">true</attribute>

        <attribute name="StateRetrievalTimeout">60000</attribute>
        <attribute name="SyncReplTimeout">17500</attribute>
        <attribute name="LockAcquisitionTimeout">15000</attribute>

        <attribute name="UseRegionBasedMarshalling">false</attribute>
        <attribute name="InactiveOnStartup">false</attribute>
           
        <attribute name="ExposeManagementStatistics">true</attribute>

    </cache-config>

    <!-- 
      | Following are JBoss Cache configurations suitable for different 
      | Hibernate 2nd Level Cache uses (e.g. entities vs. queries).
      |
      | In all cases, TransactionManager configuration not required.
      | Hibernate will plug in its own transaction manager integration. 
    -->
    
    
    <!-- A config appropriate for entity/collection caching. -->
    <cache-config name="optimistic-entity">

        <!-- Node locking scheme -->
        <attribute name="NodeLockingScheme">OPTIMISTIC</attribute>

        <!-- Mode of communication with peer caches.
        
             INVALIDATION_SYNC is highly recommended as the mode for use
             with entity and collection caches.
        -->
        <attribute name="CacheMode">INVALIDATION_SYNC</attribute>

        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">${jboss.partition.name:DefaultPartition}-optimistic-entity</attribute>
        
        <!-- Use a UDP (multicast) based stack. A udp-sync stack might be
             slightly better (no JGroups FC) but we stick with udp to
             help ensure this cache and others like timestamps-cache
             that require FC can use the same underlying JGroups resources. -->
        <attribute name="MultiplexerStack">${jboss.default.jgroups.stack:udp}</attribute>

        <!-- Whether or not to fetch state on joining a cluster. -->
        <attribute name="FetchInMemoryState">false</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup. Ignored if FetchInMemoryState=false.
        -->
        <attribute name="StateRetrievalTimeout">20000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">20000</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

       <!--
          Indicate whether to use marshalling or not. Set this to true if you 
          are running under a scoped class loader, e.g., inside an application 
          server.
       -->
       <attribute name="UseRegionBasedMarshalling">true</attribute>
       <!-- Must match the value of "useRegionBasedMarshalling" -->
       <attribute name="InactiveOnStartup">true</attribute>

       <!--  Eviction policy configurations. -->
       <attribute name="EvictionPolicyConfig">
        <config>
          <attribute name="wakeUpIntervalSeconds">5</attribute>
          <!-- Name of the DEFAULT eviction policy class. -->
          <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
          <!--  Cache wide default -->
          <region name="/_default_">
            <!-- Evict LRU node once we have more than this number of nodes -->
            <attribute name="maxNodes">10000</attribute>
            <!-- And, evict any node that hasn't been accessed in this many seconds -->
            <attribute name="timeToLiveSeconds">1000</attribute>
            <!-- Don't evict a node that's been accessed within this many seconds. 
                 Set this to a value greater than your max expected transaction length. -->
            <attribute name="minTimeToLiveSeconds">120</attribute>
          </region>
          <!--  Don't ever evict modification timestamps -->
          <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
        </config>
     </attribute>

    </cache-config>

    <!-- A config appropriate for entity/collection caching that
         uses pessimistic locking -->
    <cache-config name="pessimistic-entity">

        <!-- Node locking scheme -->
        <attribute name="NodeLockingScheme">PESSIMISTIC</attribute>

        <!--
            READ_COMMITTED is as strong as necessary for most 
            2nd Level Cache use cases.
        -->
        <attribute name="IsolationLevel">READ_COMMITTED</attribute>

        <!-- Mode of communication with peer caches.
        
             INVALIDATION_SYNC is highly recommended as the mode for use
             with entity and collection caches.
        -->
        <attribute name="CacheMode">INVALIDATION_SYNC</attribute>

        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">${jboss.partition.name:DefaultPartition}-pessimistic-entity</attribute>
        
        <!-- Use a UDP (multicast) based stack. A udp-sync stack might be
             slightly better (no JGroups FC) but we stick with udp to
             help ensure this cache and others like timestamps-cache
             that require FC can use the same underlying JGroups resources. -->
        <attribute name="MultiplexerStack">${jboss.default.jgroups.stack:udp}</attribute>

        <!-- Whether or not to fetch state on joining a cluster. -->
        <attribute name="FetchInMemoryState">false</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup. Ignored if FetchInMemoryState=false.
        -->
        <attribute name="StateRetrievalTimeout">20000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">20000</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

       <!--
          Indicate whether to use marshalling or not. Set this to true if you 
          are running under a scoped class loader, e.g., inside an application 
          server.
       -->
       <attribute name="UseRegionBasedMarshalling">true</attribute>
       <!-- Must match the value of "useRegionBasedMarshalling" -->
       <attribute name="InactiveOnStartup">true</attribute>

      <!--  Eviction policy configurations. -->
      <attribute name="EvictionPolicyConfig">
        <config>
          <attribute name="wakeUpIntervalSeconds">5</attribute>
          <!-- Name of the DEFAULT eviction policy class. -->
          <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
          <!--  Cache wide default -->
          <region name="/_default_">
            <!-- Evict LRU node once we have more than this number of nodes -->
            <attribute name="maxNodes">10000</attribute>
            <!-- And, evict any node that hasn't been accessed in this many seconds -->
            <attribute name="timeToLiveSeconds">1000</attribute>
            <!-- Don't evict a node that's been accessed within this many seconds. 
                 Set this to a value greater than your max expected transaction length. -->
            <attribute name="minTimeToLiveSeconds">120</attribute>
          </region>
          <!--  Don't ever evict modification timestamps -->
          <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
        </config>
     </attribute>

    </cache-config>        
    
    

    <!-- Same as "pessimistic-entity" but here we use REPEATABLE_READ
         instead of READ_COMMITTED. REPEATABLE_READ is only useful if the 
         application evicts/clears entities from the Hibernate Session and 
         then expects to repeatably re-read them in the same transaction.
         Otherwise, the Session's internal cache provides a repeatable-read 
         semantic. Before choosing this config, carefully read the docs
         and make sure you really need REPEATABLE_READ.
    -->
    <cache-config name="pessimistic-entity-repeatable">

        <!-- Node locking scheme -->
        <attribute name="NodeLockingScheme">PESSIMISTIC</attribute>

        <!-- Here we  use REPEATABLE_READ. -->
        <attribute name="IsolationLevel">REPEATABLE_READ</attribute>

        <!-- Mode of communication with peer caches.
        
             INVALIDATION_SYNC is highly recommended as the mode for use
             with entity and collection caches.
        -->
        <attribute name="CacheMode">INVALIDATION_SYNC</attribute>

        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">${jboss.partition.name:DefaultPartition}-pessimistic-entity-rr</attribute>
        
        <!-- Use a UDP (multicast) based stack. A udp-sync stack might be
             slightly better (no JGroups FC) but we stick with udp to
             help ensure this cache and others like timestamps-cache
             that require FC can use the same underlying JGroups resources. -->
        <attribute name="MultiplexerStack">${jboss.default.jgroups.stack:udp}</attribute>

        <!-- Whether or not to fetch state on joining a cluster. -->
        <attribute name="FetchInMemoryState">false</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup. Ignored if FetchInMemoryState=false.
        -->
        <attribute name="StateRetrievalTimeout">20000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">20000</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

       <!--
          Indicate whether to use marshalling or not. Set this to true if you 
          are running under a scoped class loader, e.g., inside an application 
          server.
       -->
       <attribute name="UseRegionBasedMarshalling">true</attribute>
       <!-- Must match the value of "useRegionBasedMarshalling" -->
       <attribute name="InactiveOnStartup">true</attribute>

       <!--  Eviction policy configurations. -->
       <attribute name="EvictionPolicyConfig">
        <config>
          <attribute name="wakeUpIntervalSeconds">5</attribute>
          <!-- Name of the DEFAULT eviction policy class. -->
          <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
          <!--  Cache wide default -->
          <region name="/_default_">
            <!-- Evict LRU node once we have more than this number of nodes -->
            <attribute name="maxNodes">10000</attribute>
            <!-- And, evict any node that hasn't been accessed in this many seconds -->
            <attribute name="timeToLiveSeconds">1000</attribute>
            <!-- Don't evict a node that's been accessed within this many seconds. 
                 Set this to a value greater than your max expected transaction length. -->
            <attribute name="minTimeToLiveSeconds">120</attribute>
          </region>
          <!--  Don't ever evict modification timestamps -->
          <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
        </config>
     </attribute>

    </cache-config>     



    <!-- A config appropriate for query caching. Does not replicate
         queries. DO NOT STORE TIMESTAMPS IN THIS CACHE.
    -->
    <cache-config name="local-query">

        <!-- Node locking scheme -->
        <attribute name="NodeLockingScheme">OPTIMISTIC</attribute>

        <attribute name="CacheMode">LOCAL</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

        <!--  Eviction policy configurations. -->
        <attribute name="EvictionPolicyConfig">
          <config>
            <attribute name="wakeUpIntervalSeconds">5</attribute>
            <!-- Name of the DEFAULT eviction policy class. -->
            <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
            <!--  Cache wide default -->
            <region name="/_default_">
               <!-- Evict LRU node once we have more than this number of nodes -->
               <attribute name="maxNodes">10000</attribute>
               <!-- And, evict any node that hasn't been accessed in this many seconds -->
               <attribute name="timeToLiveSeconds">1000</attribute>
               <!-- Don't evict a node that's been accessed within this many seconds. 
                    Set this to a value greater than your max expected transaction length. -->
               <attribute name="minTimeToLiveSeconds">120</attribute>
            </region>
            <!--  Don't ever evict modification timestamps -->
            <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
          </config>
       </attribute>

    </cache-config> 
    

    <!-- A query cache that replicates queries. Replication is asynchronous.
         DO NOT STORE TIMESTAMPS IN THIS CACHE as no initial state transfer
         is performed.
    -->
    <cache-config name="replicated-query">

        <!-- Node locking scheme -->
        <attribute name="NodeLockingScheme">OPTIMISTIC</attribute>

        <!-- Mode of communication with peer caches.
        
             REPL_ASYNC means replicate but sender does not block waiting for
             peers to acknowledge applying the change. Valid for queries as
             the timestamp cache mechanism will allow Hibernate to discard
             out-of-date queries.
        -->
        <attribute name="CacheMode">REPL_ASYNC</attribute>

        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">${jboss.partition.name:DefaultPartition}-replicated-query</attribute>
        
        <!-- Use a UDP (multicast) based stack -->
        <attribute name="MultiplexerStack">${jboss.default.jgroups.stack:udp}</attribute>

        <!-- Whether or not to fetch state on joining a cluster. -->
        <attribute name="FetchInMemoryState">false</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup. Ignored if FetchInMemoryState=false.
        -->
        <attribute name="StateRetrievalTimeout">20000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">20000</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

       <!--
          Indicate whether to use marshalling or not. Set this to true if you 
          are running under a scoped class loader, e.g., inside an application 
          server.
       -->
       <attribute name="UseRegionBasedMarshalling">true</attribute>
       <!-- Must match the value of "useRegionBasedMarshalling" -->
       <attribute name="InactiveOnStartup">true</attribute>

       <!--  Eviction policy configurations. -->
       <attribute name="EvictionPolicyConfig">
        <config>
          <attribute name="wakeUpIntervalSeconds">5</attribute>
          <!-- Name of the DEFAULT eviction policy class. -->
          <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
          <!--  Cache wide default -->
          <region name="/_default_">
            <!-- Evict LRU node once we have more than this number of nodes -->
            <attribute name="maxNodes">10000</attribute>
            <!-- And, evict any node that hasn't been accessed in this many seconds -->
            <attribute name="timeToLiveSeconds">1000</attribute>
            <!-- Don't evict a node that's been accessed within this many seconds. 
                 Set this to a value greater than your max expected transaction length. -->
            <attribute name="minTimeToLiveSeconds">120</attribute>
          </region>
          <!--  Don't ever evict modification timestamps -->
          <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
        </config>
     </attribute>

    </cache-config>     
    
    

    <!-- Optimized for timestamp caching. A clustered timestamp cache
         is required if query caching is used, even if the query cache
         itself is configured with CacheMode=LOCAL.
    -->
    <cache-config name="timestamps-cache">

        <!-- Node locking scheme -->
        <attribute name="NodeLockingScheme">PESSIMISTIC</attribute>

        <!--
            READ_COMMITTED is as strong as necessary.
        -->
        <attribute name="IsolationLevel">REPEATABLE_READ</attribute>

        <!-- Cannot be INVALIDATION. ASYNC for improved performance. -->
        <attribute name="CacheMode">REPL_ASYNC</attribute>

        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">${jboss.partition.name:DefaultPartition}-timestamps-cache</attribute>
        
        <!-- Use a UDP (multicast) based stack -->
        <attribute name="MultiplexerStack">${jboss.default.jgroups.stack:udp}</attribute>

        <!-- Used for timestamps, so must fetch state. -->
        <attribute name="FetchInMemoryState">true</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup. Ignored if FetchInMemoryState=false.
        -->
        <attribute name="StateRetrievalTimeout">20000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">20000</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

       <!--
          Indicate whether to use marshalling or not. Set this to true if you 
          are running under a scoped class loader, e.g., inside an application 
          server.
       -->
       <attribute name="UseRegionBasedMarshalling">true</attribute>
       <!-- Must match the value of "useRegionBasedMarshalling" -->
       <attribute name="InactiveOnStartup">true</attribute>

      <!--  Eviction policy configurations. -->
      <attribute name="EvictionPolicyConfig">
        <config>
          <attribute name="wakeUpIntervalSeconds">5</attribute>
          <!-- Name of the DEFAULT eviction policy class. -->
          <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
          <!--  Cache wide default -->
          <region name="/_default_">
            <!-- Evict LRU node once we have more than this number of nodes -->
            <attribute name="maxNodes">10000</attribute>
            <!-- And, evict any node that hasn't been accessed in this many seconds -->
            <attribute name="timeToLiveSeconds">1000</attribute>
            <!-- Don't evict a node that's been accessed within this many seconds. 
                 Set this to a value greater than your max expected transaction length. -->
            <attribute name="minTimeToLiveSeconds">120</attribute>
          </region>
          <!--  Don't ever evict modification timestamps -->
          <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
        </config>
     </attribute>

    </cache-config>  
    
    

    <!-- A config appropriate for a cache that's shared for
         entity, collection, query and timestamp caching. Not an advised
         configuration, since it requires cache mode REPL_SYNC, which is the 
         least efficient mode. Also requires a full state transfer at startup,
         which can be expensive. Uses optimistic locking -->
    <cache-config name="optimistic-shared">

        <!-- Node locking scheme -->
        <attribute name="NodeLockingScheme">OPTIMISTIC</attribute>

        <!-- Must use REPL since used for timestamp caching. 
             Must use SYNC to maintain cache consistency for entities.
        -->
        <attribute name="CacheMode">REPL_SYNC</attribute>
        
        <!-- With OPTIMISTIC with replication we need to use synchronous commits. -->
        <attribute name="SyncCommitPhase">true</attribute>
        <attribute name="SyncRollbackPhase">true</attribute>
        
        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">${jboss.partition.name:DefaultPartition}-optimistic-shared</attribute>
        
        <!-- Use a UDP (multicast) based stack. Need JGroups flow control (FC)
             because timestamp communication will not require a synchronous response.
        -->
        <attribute name="MultiplexerStack">${jboss.default.jgroups.stack:udp}</attribute>

        <!-- Used for timestamps, so must fetch state. -->
        <attribute name="FetchInMemoryState">true</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup. Ignored if FetchInMemoryState=false.
        -->
        <attribute name="StateRetrievalTimeout">20000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">20000</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

       <!--
          Indicate whether to use marshalling or not. Set this to true if you 
          are running under a scoped class loader, e.g., inside an application 
          server.
       -->
       <attribute name="UseRegionBasedMarshalling">true</attribute>
       <!-- Must match the value of "useRegionBasedMarshalling" -->
       <attribute name="InactiveOnStartup">true</attribute>

       <!--  Eviction policy configurations. -->
       <attribute name="EvictionPolicyConfig">
        <config>
          <attribute name="wakeUpIntervalSeconds">5</attribute>
          <!-- Name of the DEFAULT eviction policy class. -->
          <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
          <!--  Cache wide default -->
          <region name="/_default_">
            <!-- Evict LRU node once we have more than this number of nodes -->
            <attribute name="maxNodes">10000</attribute>
            <!-- And, evict any node that hasn't been accessed in this many seconds -->
            <attribute name="timeToLiveSeconds">1000</attribute>
            <!-- Don't evict a node that's been accessed within this many seconds. 
                 Set this to a value greater than your max expected transaction length. -->
            <attribute name="minTimeToLiveSeconds">120</attribute>
          </region>
          <!--  Don't ever evict modification timestamps -->
          <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
        </config>
     </attribute>

    </cache-config>   
    
    

    <!-- A config appropriate for a cache that's shared for
         entity, collection, query and timestamp caching. Not an advised
         configuration, since it requires cache mode REPL_SYNC, which is the 
         least efficient mode. Also requires a full state transfer at startup,
         which can be expensive. Uses pessmistic locking.
    -->
    <cache-config name="pessimistic-shared">

        <!-- Node locking scheme -->
        <attribute name="NodeLockingScheme">PESSIMISTIC</attribute>

        <!--
            READ_COMMITTED is as strong as necessary for most 
            2nd Level Cache use cases.
        -->
        <attribute name="IsolationLevel">REPEATABLE_READ</attribute>

        <!-- Must use REPL since used for timestamp caching. 
             Must use SYNC to maintain cache consistency for entities.
        -->
        <attribute name="CacheMode">REPL_SYNC</attribute>

        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">${jboss.partition.name:DefaultPartition}-pessimistic-shared</attribute>
        
        <!-- Use a UDP (multicast) based stack. Need JGroups flow control (FC)
             because timestamp communication will not require a synchronous response.
        -->
        <attribute name="MultiplexerStack">${jboss.default.jgroups.stack:udp}</attribute>

        <!-- Used for timestamps, so must fetch state. -->
        <attribute name="FetchInMemoryState">true</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup.
        -->
        <attribute name="StateRetrievalTimeout">20000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">20000</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

       <!--
          Indicate whether to use marshalling or not. Set this to true if you 
          are running under a scoped class loader, e.g., inside an application 
          server. Default is "false".
       -->
       <attribute name="UseRegionBasedMarshalling">true</attribute>
       <!-- Must match the value of "useRegionBasedMarshalling" -->
       <attribute name="InactiveOnStartup">true</attribute>

       <!--  Eviction policy configurations. -->
       <attribute name="EvictionPolicyConfig">
        <config>
          <attribute name="wakeUpIntervalSeconds">5</attribute>
          <!-- Name of the DEFAULT eviction policy class. -->
          <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
          <!--  Cache wide default -->
          <region name="/_default_">
            <!-- Evict LRU node once we have more than this number of nodes -->
            <attribute name="maxNodes">10000</attribute>
            <!-- And, evict any node that hasn't been accessed in this many seconds -->
            <attribute name="timeToLiveSeconds">1000</attribute>
            <!-- Don't evict a node that's been accessed within this many seconds. 
                 Set this to a value greater than your max expected transaction length. -->
            <attribute name="minTimeToLiveSeconds">120</attribute>
          </region>
          <!--  Don't ever evict modification timestamps -->
          <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
        </config>
     </attribute>

    </cache-config>  
    
    

    <!-- Same as "pessimistic-shared" but here we use REPEATABLE_READ
         instead of READ_COMMITTED. REPEATABLE_READ is only useful if the 
         application evicts/clears entities from the Hibernate Session and 
         then expects to repeatably re-read them in the same transaction.
         Otherwise, the Session's internal cache provides a repeatable-read 
         semantic. Before choosing this config, carefully read the docs
         and make sure you really need REPEATABLE_READ.
    -->
    <cache-config name="pessimistic-shared-repeatable">

        <!-- Node locking scheme -->
        <attribute name="NodeLockingScheme">PESSIMISTIC</attribute>

        <!-- Here we  use REPEATABLE_READ. -->
        <attribute name="IsolationLevel">REPEATABLE_READ</attribute>

        <!-- Must use REPL since used for timestamp caching. 
             Must use SYNC to maintain cache coherency for entities.
        -->
        <attribute name="CacheMode">REPL_SYNC</attribute>

        <!-- Name of cluster. Needs to be the same for all members, in order
             to find each other -->
        <attribute name="ClusterName">${jboss.partition.name:DefaultPartition}-pessimistic-shared-rr</attribute>
        
        <!-- Use a UDP (multicast) based stack. Need JGroups flow control (FC)
             because timestamp communication will not require a synchronous response.
        -->
        <attribute name="MultiplexerStack">${jboss.default.jgroups.stack:udp}</attribute>

        <!-- Used for timestamps, so must fetch state. -->
        <attribute name="FetchInMemoryState">true</attribute>

        <!--
          The max amount of time (in milliseconds) we wait until the
          state (ie. the contents of the cache) are retrieved from
          existing members at startup.
        -->
        <attribute name="StateRetrievalTimeout">20000</attribute>

        <!--
            Number of milliseconds to wait until all responses for a
            synchronous call have been received.
        -->
        <attribute name="SyncReplTimeout">20000</attribute>

        <!-- Max number of milliseconds to wait for a lock acquisition -->
        <attribute name="LockAcquisitionTimeout">15000</attribute>

       <!--
          Indicate whether to use marshalling or not. Set this to true if you 
          are running under a scoped class loader, e.g., inside an application 
          server.
       -->
       <attribute name="UseRegionBasedMarshalling">true</attribute>
       <!-- Must match the value of "useRegionBasedMarshalling" -->
       <attribute name="InactiveOnStartup">true</attribute>

       <!--  Eviction policy configurations. -->
       <attribute name="EvictionPolicyConfig">
        <config>
          <attribute name="wakeUpIntervalSeconds">5</attribute>
          <!-- Name of the DEFAULT eviction policy class. -->
          <attribute name="policyClass">org.jboss.cache.eviction.LRUPolicy</attribute>
          <!--  Cache wide default -->
          <region name="/_default_">
            <!-- Evict LRU node once we have more than this number of nodes -->
            <attribute name="maxNodes">10000</attribute>
            <!-- And, evict any node that hasn't been accessed in this many seconds -->
            <attribute name="timeToLiveSeconds">1000</attribute>
            <!-- Don't evict a node that's been accessed within this many seconds. 
                 Set this to a value greater than your max expected transaction length. -->
            <attribute name="minTimeToLiveSeconds">120</attribute>
          </region>
          <!--  Don't ever evict modification timestamps -->
          <region name="/TS" policyClass="org.jboss.cache.eviction.NullEvictionPolicy"/>
        </config>
     </attribute>

    </cache-config>
    
</cache-configs>
